<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>fed3.core.fedframe API documentation</title>
<meta name="description" content="The FEDFrame is a subclass of the pandas DataFrame.
It is tailored
to FED3 data, defining additional attributes and methods for FED3-specific
…" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fed3.core.fedframe</code></h1>
</header>
<section id="section-intro">
<p>The FEDFrame is a subclass of the pandas DataFrame.
It is tailored
to FED3 data, defining additional attributes and methods for FED3-specific
operations.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
The FEDFrame is a subclass of the pandas DataFrame.  It is tailored
to FED3 data, defining additional attributes and methods for FED3-specific
operations.
&#34;&#34;&#34;

__all__ = [&#39;FEDFrame&#39;]

__pdoc__ = {&#39;FEDFrame._load_init&#39;:True,
            &#39;FEDFrame.ipi&#39;:False}

from difflib import SequenceMatcher
import warnings

import numpy as np
import pandas as pd


FIXED_COLS = [&#39;Device_Number&#39;,
              &#39;Battery_Voltage&#39;,
              &#39;Motor_Turns&#39;,
              &#39;Session_Type&#39;,
              &#39;Event&#39;,
              &#39;Active_Poke&#39;,
              &#39;Left_Poke_Count&#39;,
              &#39;Right_Poke_Count&#39;,
              &#39;Pellet_Count&#39;,
              &#39;Retrieval_Time&#39;,]

NEEDED_COLS = [&#39;Pellet_Count&#39;,
               &#39;Left_Poke_Count&#39;,
               &#39;Right_Poke_Count&#39;,]

ZERO_DATE = pd.Timestamp(year=2000, month=1, day=1)

def _filterout(series, dropna=False, dropzero=False, deduplicate=False):
    &#34;&#34;&#34;Helper func for condensing series returned from FEDFrame methods.&#34;&#34;&#34;

    if dropna:
        series = series.dropna()
    if dropzero:
        series = series[series != 0]
    if deduplicate:
        series = series[~series.duplicated()]

    return series

class FEDFrame(pd.DataFrame):
    &#39;&#39;&#39;The main object interface for FED3 data in the fed3 library.  Provides
    a 2D table for storing FED3 data.

    FEDFrame is a subclass of the DataFrame, which allows for the highly-developed
    data manipulation operations provided by pandas.  Most things you can do
    with a pandas DataFrame can also be done with a FEDFrame.

    Note there is no equivalent of the pandas Series which is specific to FEDs.

    FEDFrame provides additional attributes and methods which are specific
    to FED3 data.  See additional documentation for these below.

    Most of the time, FED3 data will be accessed directly from the logged CSV
    files.  In this case, using the FEDFrame constructor is not recommended;
    you should instead use `fed3.core.load()`.  But if for some reason you already
    have FED3 data loaded into a pandas DataFrame, you can make use of the
    constructor and the `fed3.core.fedframe.FEDFrame._load_init()` function to
    get full FEDFrame functionality.

    Other links:

    - pandas: https://pandas.pydata.org/docs/index.html
    - pandas DataFrame: https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html
    - Subclassing pandas: https://pandas.pydata.org/docs/development/extending.html&#39;&#39;&#39;

    _metadata = [&#39;name&#39;, &#39;path&#39;, &#39;foreign_columns&#39;, &#39;missing_columns&#39;,
                 &#39;_alignment&#39;, &#39;_current_offset&#39;]

    # ---- Properties

    @property
    def _constructor(self):
        &#39;&#39;&#39;Maintains the FEDFrame type for derivates created from self.
        See https://pandas.pydata.org/docs/development/extending.html&#39;&#39;&#39;
        return FEDFrame

    @property
    def duration(self):
        &#34;&#34;&#34;Time delta of last timestamp and first timestamp.&#34;&#34;&#34;
        return self.end_time-self.start_time

    @property
    def end_time(self):
        &#34;&#34;&#34;Last timestamp in file.&#34;&#34;&#34;
        return pd.Timestamp(self.index.values[-1])

    @property
    def events(self):
        &#39;&#39;&#39;Number of logged events (i.e. rows).&#39;&#39;&#39;
        return len(self.data)

    @property
    def fedmode(self):
        &#39;&#39;&#39;FED3 operating mode for this data.&#39;&#39;&#39;
        return self.determine_mode()

    @property
    def start_time(self):
        &#39;&#39;&#39;First timestamp in file.&#39;&#39;&#39;
        return pd.Timestamp(self.index.values[0])

    # ---- &#34;Private&#34;

    def _binary_correct_pokes(self):
        l = self._binary_pokes(&#39;left&#39;)
        r = self._binary_pokes(&#39;right&#39;)
        active_l = self[&#39;Active_Poke&#39;] == &#39;Left&#39;
        active_r = self[&#39;Active_Poke&#39;] == &#39;Right&#39;
        correct = ((l * active_l).astype(int) | (r * active_r).astype(int))

        return correct

    def _binary_error_pokes(self):
        l = self._binary_pokes(&#39;left&#39;)
        r = self._binary_pokes(&#39;right&#39;)
        active_l = self[&#39;Active_Poke&#39;] == &#39;Left&#39;
        active_r = self[&#39;Active_Poke&#39;] == &#39;Right&#39;
        error = ((l * active_r).astype(int) | (r * active_l).astype(int))

        return error

    def _binary_pellets(self):
        bp = self[&#39;Pellet_Count&#39;].diff().copy()
        if not bp.empty:
            bp.iloc[0] = int(self.event_type(bp.index[0]) == &#39;Pellet&#39;)

        return bp

    def _binary_poke_for_side(self, side):
        col = {&#39;left&#39;: &#39;Left_Poke_Count&#39;, &#39;right&#39;: &#39;Right_Poke_Count&#39;}[side]
        bp = self[col].diff().copy()
        if not bp.empty:
            bp.iloc[0] = int(self.event_type(bp.index[0]).lower() == side)

        return bp

    def _binary_pokes(self, kind=&#39;any&#39;):
        kind = kind.lower()
        kinds = [&#39;left&#39;, &#39;right&#39;, &#39;any&#39;, &#39;correct&#39;, &#39;error&#39;]
        if kind not in kinds:
            raise ValueError(f&#39;`kind` must be one of  {kinds}, not {kind}&#39;)

        if kind == &#39;any&#39;:
            l = self._binary_poke_for_side(&#39;left&#39;)
            r = self._binary_poke_for_side(&#39;right&#39;)
            bp = ((l == 1) | (r==1)).astype(int)

        elif kind in [&#39;left&#39;, &#39;right&#39;]:
            bp = self._binary_poke_for_side(kind).astype(int)

        elif kind in [&#39;correct&#39;, &#39;error&#39;]:
            bp = self._binary_correct_pokes() if kind == &#39;correct&#39; else self._binary_error_pokes()

        return bp

    def _cumulative_poke_for_side(self, side):
        col = {&#39;left&#39;: &#39;Left_Poke_Count&#39;, &#39;right&#39;: &#39;Right_Poke_Count&#39;}[side]
        cp = self[col]

        return cp

    def _cumulative_pokes(self, kind=&#39;any&#39;):
        kind = kind.lower()
        kinds = [&#39;left&#39;, &#39;right&#39;, &#39;any&#39;, &#39;correct&#39;, &#39;error&#39;]
        if kind not in kinds:
            raise ValueError(f&#39;`kind` must be one of  {kinds}, not {kind}&#39;)

        if kind == &#39;any&#39;:
            l = self._cumulative_poke_for_side(&#39;left&#39;)
            r = self._cumulative_poke_for_side(&#39;right&#39;)
            cp = (l + r).astype(int)

        elif kind in [&#39;left&#39;, &#39;right&#39;]:
            cp = self._cumulative_poke_for_side(kind).astype(int)

        elif kind in [&#39;correct&#39;, &#39;error&#39;]:
            bp = self._binary_correct_pokes() if kind == &#39;correct&#39; else self._binary_error_pokes()
            cp = bp.cumsum()

        return cp

    def _fix_column_names(self):
        &#39;&#39;&#39;
        Checks for and fixes old FED3 issue where column names included a
        trailing/starting space.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        self.foreign_columns = []
        for col in self.columns:
            for fix in FIXED_COLS:
                likeness = SequenceMatcher(a=col, b=fix).ratio()
                if likeness &gt; 0.85:
                    self.rename(columns={col:fix}, inplace=True)
                    break
                self.foreign_columns.append(col)
        self.missing_columns = [col for col in NEEDED_COLS if
                                col not in self.columns]

    def _handle_retrieval_time(self):
        if &#39;Retrieval_Time&#39; not in self.columns:
            return
        self[&#39;Retrieval_Time&#39;] = pd.to_numeric(self[&#39;Retrieval_Time&#39;], errors=&#39;coerce&#39;)


    def _load_init(self, name=None, path=None, deduplicate_index=None):
        &#39;&#39;&#39;
        Initialize FEDFrame attributes and apply some data cleaning.

        This method is marked &#34;private&#34; because it is typically invoked
        automatically when loading data from local files.  The only
        use case is when you have existing pandas data which you want
        to convert into FEDFrame data.  The following demonstrates this
        use case, but note that **it is not recommended**
        (use `fed3.core.load()` instead):

        ```python
        import fed3
        import pandas as pd

        data = pd.read_csv(&#34;/some/file.csv&#34;)
        data = fed3.FEDFrame(data)

        # do the following to get full functionality
        data._load_init()
        ```

        Parameters
        ----------
        name : str, optional
            Name to give the FEDFrame. The default is None.
        path : str, optional
            Set a local data path for the data. The default is None.
        deduplicate_index : str, optional
            When passed, applies a method for handling duplicate timestamps.
            Not passed by default.  See `FEDFrame.deduplicate_index()` for
            allowable methods.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        self.name = name
        self.path = path
        self._fix_column_names()
        self._handle_retrieval_time()
        self._alignment = &#39;datetime&#39;
        self._current_offset = pd.Timedelta(0)
        if deduplicate_index is not None:
            self.deduplicate_index(method=deduplicate_index)
        if self.check_duplicated_index():
            warnings.warn(&#34;Index has duplicate values, which may prevent some &#34;
                          &#34;fed3 operations.  Use the deuplicate_index() method &#34;
                          &#34;to remove duplicate timestamps.&#34;, RuntimeWarning)

    # ---- Public

    def check_duplicated_index(self):
        &#39;&#39;&#39;
        Checks if the data has duplicated timestamps.

        Returns
        -------
        bool
            `True` if duplicates found, else `False`.

        &#39;&#39;&#39;
        return self.index.duplicated().any()

    def deduplicate_index(self, method=&#39;keep_first&#39;, offset=&#39;1S&#39;):
        &#39;&#39;&#39;
        Apply a method to remove duplicate timestamps from the data.

        With FEDFrames, the timestamp column (typically the column
        &#39;MM:DD:YYYY hh:mm:ss&#39;) is used as the row labels (AKA the
        `index` in pandas, [see here](https://pandas.pydata.org/docs/reference/api/pandas.Index.html)).
        Some operations which invole selecting data based on this index
        can fail when there are duplicate entries.

        FED3 data should not generally have duplicated timestamps, however
        they do arise due to two main causes.  One cause is transient
        logging errors, which should be rare (but may be more common with
        earlier FED software).  The other, more common, cause is
        data editing with Microsoft Excel, which has been documented elsewhere
        (see links below).

        Note that this method does not recover any information that is lost;
        it either removes duplicated indices or applies simple rules to alter
        them.  When available, non-duplicated data should be loaded into
        the program.

        fed3 should raise a warning when files with duplicated timestamps
        are loaded. The status of the index can also be checked with
        `check_duplicated_index()`.

        Parameters
        ----------
        method : str, optional
            Method for removing duplicates.  Options are:

            - `&#39;keep_first&#39;`: keep only the first instance of each duplicate
            set (default)
            - `&#39;keep_last&#39;`: keep only the last instance of each duplicate set
            - `&#39;remove&#39;`: delete any rows with duplicate timestamps
            - `&#39;offset&#39;`: add a small time offset to each date - does so
            iteratively until the index is not duplicated.
            - `&#39;interpolate&#39;`: offset duplicates such that they are spaced
            evenly between their value and the next timestamp in the series

            Note that `&#39;interpolate&#39;` and `&#39;offset&#39;` should preserve the
            length of the FEDFrame, while other options can reduce it.

        offset : str, optional
            Pandas time offset string, only used when `method=&#39;offset&#39;`.
            The default is `&#39;1S&#39;`.

        Raises
        ------
        ValueError
            Trying to use `&#39;interpolate&#39;` when the last timestamp is duplicated.

        Returns
        -------
        None.  Data is modified in place.

        &#39;&#39;&#39;

        if method not in [&#39;keep_first&#39;, &#39;keep_last&#39;, &#39;remove&#39;,
                             &#39;offset&#39;, &#39;interpolate&#39;]:
            raise ValueError(f&#39;`method` must be one of {method}, not &#34;{method}&#34;&#39;)

        if method == &#39;keep_first&#39;:
            mask = ~ self.index.duplicated(keep=&#39;first&#39;)
            self.query(&#39;@mask&#39;, inplace=True)
        elif method == &#39;keep_last&#39;:
            mask = ~ self.index.duplicated(keep=&#39;last&#39;)
            self.query(&#39;@mask&#39;, inplace=True)
        elif method == &#39;remove&#39;:
            mask = ~ self.index.duplicated(keep=False)
            self.query(&#39;@mask&#39;, inplace=True)
        elif method == &#39;offset&#39;:
            dt = pd.to_timedelta(offset)
            while self.check_duplicated_index():
                self.index = np.where(self.index.duplicated(),
                                      self.index + dt,
                                      self.index)
        elif method == &#39;interpolate&#39;:
            if self.index.duplicated()[-1]:
                raise ValueError(&#34;Cannot interpolate when the last &#34;
                                 &#34;timestamp is duplicated; try a different &#34;
                                 &#34;deduplication method.&#34;)
            t0 = self.index[0]
            s = pd.Series(self.index)
            s[s.duplicated()] = None
            self.index = t0 + pd.to_timedelta((s - t0).dt.total_seconds().interpolate(), unit=&#39;seconds&#39;)

    def determine_mode(self):
        &#39;&#39;&#39;
        Return the recording mode of the current FED data.  This function tries
        to take this literally from the data headers.  There are likely
        to be problems for custom programs or particular FED software versions.

        Returns
        -------
        mode : str
            String indicating the mode.

        &#39;&#39;&#39;
        mode = &#39;Unknown&#39;
        column = pd.Series(dtype=object)
        for col in [&#39;FR&#39;,&#39;FR_Ratio&#39;,&#39; FR_Ratio&#39;,&#39;Mode&#39;,&#39;Session_Type&#39;]:
            if col in self.columns:
                column = self[col]
        if not column.empty:
            if all(isinstance(i,int) for i in column):
                if len(set(column)) == 1:
                    mode = &#39;FR&#39; + str(column[0])
                else:
                    mode = &#39;PR&#39;
            elif &#39;PR&#39; in column[0]:
                mode = &#39;PR&#39;
            else:
                mode = str(column[0])
        return mode

    def event_type(self, timestamp, poke_side=True):
        &#39;&#39;&#39;
        Return the type of a given timestamp within the data (pellet or poke).

        Parameters
        ----------
        timestamp : str, `pandas.Timestamp`
            timestamp to query.
        poke_side : bool, optional
            When True (default), will try to return `&#39;Left&#39;` or `&#39;Right&#39;`
            when the event is a poke.

        Raises
        ------
        Exception
            Fails when the type can&#39;t automatically be determined.

        Returns
        -------
        str
            Event type for queried timestamp.

        &#39;&#39;&#39;
        if &#39;Event&#39; in self.columns:
            return self.loc[timestamp, &#39;Event&#39;]
        else:
            pellet = self.loc[timestamp, &#39;Pellet_Count&#39;] == 0
            left = self.loc[timestamp, &#39;Left_Poke_Count&#39;] == 0
            right = self.loc[timestamp, &#39;Right_Poke_Count&#39;] == 0
            if sum((pellet, left, right)) == 2:
                if pellet:
                    return &#39;Pellet&#39;
                if left:
                    return &#39;Left&#39; if poke_side else &#39;Poke&#39;
                if right:
                    return &#39;Right&#39; if poke_side else &#39;Poke&#39;
            else:
                raise Exception(&#39;Cannot determine event for timestamp with &#39;
                                &#39;no &#34;Event&#34; column and multiple non-zero &#39;
                                &#39;entries for pellets and pokes.&#39;)

    def interpellet_intervals(self, check_concat=True, condense=False):
        &#39;&#39;&#39;
        Calculate the interpellet intervals for each pellet event.
        This is the time (in minutes) since the last pellet was retrieved.

        Note that there is a shortcut for this method: `ipi`.

        Parameters
        ----------
        check_concat : bool, optional
            Removes IPIs when they are identified as coming directly after
            data concatenation. The default is True.  This will only work
            when data were concatenated with fed3.
        condense : bool, optional
            Return only rows where there are interpellet intervals.
            The default is False.  When False, the returned Series will
            have same length as full FEDFrame.

        Returns
        -------
        interpellet : pandas.Series
            Pandas Series containing the interpellet intervals.

        &#39;&#39;&#39;
        bp = self._binary_pellets()
        bp = bp[bp == 1]
        diff = bp.index.to_series().diff().dt.total_seconds() / 60

        interpellet = pd.Series(np.nan, index = self.index)
        interpellet.loc[diff.index] = diff

        if check_concat and &#39;Concat_#&#39; in self.columns:
            #this can&#39;t do duplicate indexes
            if not any(self.index.duplicated()):
                #thanks to this answer https://stackoverflow.com/a/47115490/13386979
                dropped = interpellet.dropna()
                pos = dropped.index.to_series().groupby(self[&#39;Concat_#&#39;]).first()
                interpellet.loc[pos[1:]] = np.nan

        if condense:
            interpellet = interpellet.loc[bp.index]
            interpellet = _filterout(interpellet, dropna=True)

        return interpellet

    def meals(self, pellet_minimum=1, intermeal_interval=1, condense=False):
        &#39;&#39;&#39;
        Assign a meal number to each pellet retrieval.  Returns a series
        with those assignments.

        Parameters to this function determine what constitutes a meal.
        Assignments are based on interpellet intervals
        (see `FEDFrame.interpellet_intervals()`).

        Parameters
        ----------
        pellet_minimum : int, optional
            Number of pellets required in one meal. The default is 1.  For
            high numbers, some pellets can be unassigned to any meal.
        intermeal_interval : int, optional
            Maximum length of time (in minutes) that can pass between any
            two consecutive pellets assigned to the same meal. The default is 1.
        condense : False, optional
            Return only rows where there are meals (i.e. only pellet index).
            The default is False.  When False, the returned Series will
            have same length as full FEDFrame.

        Returns
        -------
        meals : pandas.Series
            pandas Series with labeled meals

        &#39;&#39;&#39;
        ipi = self.interpellet_intervals(condense=True)
        within_interval = ipi &lt; intermeal_interval
        meals = ((~within_interval).cumsum() + 1)
        above_min = meals.value_counts().sort_index() &gt;= pellet_minimum
        replacements = above_min[above_min].cumsum().reindex(above_min.index)
        meals = meals.map(replacements)
        if not condense:
            meals = meals.reindex(self.index)
        return meals

    def pellets(self, cumulative=True, condense=False):
        &#39;&#39;&#39;
        Provide a series containing pellet retrieval information.

        Parameters
        ----------
        cumulative : bool, optional
            When True (default), the values returned are a cumulative pellet count.
            When False, the values are binary.
        condense : bool, optional
            Return only rows corresponding to pellets.
            The default is False.  When False, the returned Series will
            have same length as full FEDFrame.

        Returns
        -------
        y : pandas Series
            pandas Series containing pellet retrieval counts/indicators.
        &#39;&#39;&#39;
        if cumulative:
            y = self[&#39;Pellet_Count&#39;]
            if condense:
                y = _filterout(y, deduplicate=True, dropzero=True)

        else:
            y = self._binary_pellets()
            if condense:
                y = _filterout(y, dropzero=True)

        return y

    def pokes(self, kind=&#39;any&#39;, cumulative=True, condense=False):
        &#39;&#39;&#39;
        Get an array of poke events.

        Parameters
        ----------
        kind : str, optional
            Key for determining the poke type returned. The default is &#39;any&#39;
            (any poke event).  Other options are &#39;left&#39;, &#39;right&#39;, &#39;correct&#39;,
            and &#39;error&#39;.
        cumulative : bool, optional
            When True (default), the values returned are a cumulative poke count.
            When False, the values are binary.
        condense : bool, optional
            Return only rows corresponding to poke events.
            The default is False.  When False, the returned Series will
            have same length as full FEDFrame.

        Raises
        ------
        ValueError
            Unaccetped key passed to `kind`.

        Returns
        -------
        y : pandas Series
            Pandas Series containing poke counts/indicators.

        &#39;&#39;&#39;

        kind = kind.lower()
        kinds = [&#39;left&#39;, &#39;right&#39;, &#39;any&#39;, &#39;correct&#39;, &#39;error&#39;]
        if kind not in kinds:
            raise ValueError(f&#39;`kind` must be one of  {kinds}, not {kind}&#39;)

        if cumulative:
            y = self._cumulative_pokes(kind)
            if condense:
                y = _filterout(y, deduplicate=True, dropzero=True)

        else:
            y = self._binary_pokes(kind)
            if condense:
                y = _filterout(y, dropzero=True)

        return y

    def reassign_events(self, include_side=True):
        &#39;&#39;&#39;
        Run an intitial assignment or reassignment of the &#34;Event&#34; column.

        Parameters
        ----------
        include_side : bool, optional
            Label poke events with &#34;Left&#34; and &#34;Right&#34; instead of &#34;Poke&#34;.
            The default is True.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        if include_side:
            events = pd.Series(np.nan, index=self.index)
            events.loc[self._binary_pellets().astype(bool)] = &#39;Pellet&#39;
            events.loc[self._binary_pokes(&#39;left&#39;).astype(bool)] = &#39;Left&#39;
            events.loc[self._binary_pokes(&#39;right&#39;).astype(bool)] = &#39;Right&#39;
        else:
            events = np.where(self._binary_pellets(), &#39;Pellet&#39;, &#39;Poke&#39;)
        self[&#39;Event&#39;] = events

    def set_alignment(self, alignment, inplace=True):
        &#39;&#39;&#39;
        Shift the timestamps of a FEDFrame to allow for comparisons with other data
        recorded at different times.

        This is particularly intended for plotting with `fed3.plot`.  By default,
        fed3 will plot fed3 data over the timestamps they were recorded.  For
        temporal plots (with time on the x-axis), this disallows combination
        (e.g. averaging) of data recorded on different dates.  To combine
        these sorts of data, this function will shift the timestamps FEDFrames
        to a common time.

        There are three options for temporal alignment, &#39;datetime&#39;, &#39;time&#39;,
        and &#39;elapsed&#39;.  Note that these are the equivalents of &#39;shared date &amp; time&#39;,
        &#39;shared time&#39;, and &#39;elapsed time&#39; from FED3_Viz.

        - &#39;datetime&#39;: Use the original recorded timestamps for plotting.  This is
        the default behavior for plotting.  This is generally useful when
        all your data were collected at the same time, when you want to show
        exactly when data were recorded, or when working with plots where
        the time of recording does not matter.
        - &#39;time&#39;: Shift the timestamps so that they have the same start date,
        but preserved time of day information.  This is useful for when you
        want to compare or average data recorded on different dates, but want
        to preserve circadian patterns.
        - &#39;elapsed&#39;: Shift the timestamps such that the first recorded timestamp
        is equal to a single, shared date.  This is useful for comparing data
        relative to the initiation of the recording, and you do not need
        to preserve circadian information.

        Note that for &#39;elapsed&#39; and &#39;time&#39; alignment, the common date is set
        by the `ZERO_DATE` variable in this module.

        Parameters
        ----------
        alignment : str, &#39;datetime&#39;, &#39;time&#39;, or &#39;elapsed&#39;
            Option for temporal alignment.  See above for more information.
        inplace : bool, optional
            When True, the current FEDFrame is modified.  Else, a copy is
            returned with the new alignment.

        Raises
        ------
        ValueError
            Option for alignment not recognized.

        Returns
        -------
        newfed : fed3.FEDFrame
            FED3 data with new alignment.

        &#39;&#39;&#39;
        options = [&#39;datetime&#39;, &#39;time&#39;, &#39;elapsed&#39;]

        if alignment not in options:
            raise ValueError(f&#39;`alignment` must be one of {options}, &#39;
                             f&#39;not &#34;{alignment}&#34;&#39;)
        if alignment == &#39;datetime&#39;:
            new_diff = self._current_offset
        elif alignment == &#39;time&#39;:
            new_diff = self.index[0].date() - ZERO_DATE.date()
        elif alignment == &#39;elapsed&#39;:
            new_diff = self.index[0] - ZERO_DATE

        newfed = self if inplace else self.copy()
        newfed.index -= new_diff
        newfed._current_offset -= new_diff
        newfed._alignment = alignment

        return newfed

    # ---- Aliases
    ipi = interpellet_intervals</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fed3.core.fedframe.FEDFrame"><code class="flex name class">
<span>class <span class="ident">FEDFrame</span></span>
<span>(</span><span>data=None, index: Axes | None = None, columns: Axes | None = None, dtype: Dtype | None = None, copy: bool | None = None)</span>
</code></dt>
<dd>
<div class="desc"><p>The main object interface for FED3 data in the fed3 library.
Provides
a 2D table for storing FED3 data.</p>
<p>FEDFrame is a subclass of the DataFrame, which allows for the highly-developed
data manipulation operations provided by pandas.
Most things you can do
with a pandas DataFrame can also be done with a FEDFrame.</p>
<p>Note there is no equivalent of the pandas Series which is specific to FEDs.</p>
<p>FEDFrame provides additional attributes and methods which are specific
to FED3 data.
See additional documentation for these below.</p>
<p>Most of the time, FED3 data will be accessed directly from the logged CSV
files.
In this case, using the FEDFrame constructor is not recommended;
you should instead use <code><a title="fed3.core.load" href="index.html#fed3.core.load">load()</a></code>.
But if for some reason you already
have FED3 data loaded into a pandas DataFrame, you can make use of the
constructor and the <code><a title="fed3.core.fedframe.FEDFrame._load_init" href="#fed3.core.fedframe.FEDFrame._load_init">FEDFrame._load_init()</a></code> function to
get full FEDFrame functionality.</p>
<p>Other links:</p>
<ul>
<li>pandas: <a href="https://pandas.pydata.org/docs/index.html">https://pandas.pydata.org/docs/index.html</a></li>
<li>pandas DataFrame: <a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html">https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html</a></li>
<li>Subclassing pandas: <a href="https://pandas.pydata.org/docs/development/extending.html">https://pandas.pydata.org/docs/development/extending.html</a></li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FEDFrame(pd.DataFrame):
    &#39;&#39;&#39;The main object interface for FED3 data in the fed3 library.  Provides
    a 2D table for storing FED3 data.

    FEDFrame is a subclass of the DataFrame, which allows for the highly-developed
    data manipulation operations provided by pandas.  Most things you can do
    with a pandas DataFrame can also be done with a FEDFrame.

    Note there is no equivalent of the pandas Series which is specific to FEDs.

    FEDFrame provides additional attributes and methods which are specific
    to FED3 data.  See additional documentation for these below.

    Most of the time, FED3 data will be accessed directly from the logged CSV
    files.  In this case, using the FEDFrame constructor is not recommended;
    you should instead use `fed3.core.load()`.  But if for some reason you already
    have FED3 data loaded into a pandas DataFrame, you can make use of the
    constructor and the `fed3.core.fedframe.FEDFrame._load_init()` function to
    get full FEDFrame functionality.

    Other links:

    - pandas: https://pandas.pydata.org/docs/index.html
    - pandas DataFrame: https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html
    - Subclassing pandas: https://pandas.pydata.org/docs/development/extending.html&#39;&#39;&#39;

    _metadata = [&#39;name&#39;, &#39;path&#39;, &#39;foreign_columns&#39;, &#39;missing_columns&#39;,
                 &#39;_alignment&#39;, &#39;_current_offset&#39;]

    # ---- Properties

    @property
    def _constructor(self):
        &#39;&#39;&#39;Maintains the FEDFrame type for derivates created from self.
        See https://pandas.pydata.org/docs/development/extending.html&#39;&#39;&#39;
        return FEDFrame

    @property
    def duration(self):
        &#34;&#34;&#34;Time delta of last timestamp and first timestamp.&#34;&#34;&#34;
        return self.end_time-self.start_time

    @property
    def end_time(self):
        &#34;&#34;&#34;Last timestamp in file.&#34;&#34;&#34;
        return pd.Timestamp(self.index.values[-1])

    @property
    def events(self):
        &#39;&#39;&#39;Number of logged events (i.e. rows).&#39;&#39;&#39;
        return len(self.data)

    @property
    def fedmode(self):
        &#39;&#39;&#39;FED3 operating mode for this data.&#39;&#39;&#39;
        return self.determine_mode()

    @property
    def start_time(self):
        &#39;&#39;&#39;First timestamp in file.&#39;&#39;&#39;
        return pd.Timestamp(self.index.values[0])

    # ---- &#34;Private&#34;

    def _binary_correct_pokes(self):
        l = self._binary_pokes(&#39;left&#39;)
        r = self._binary_pokes(&#39;right&#39;)
        active_l = self[&#39;Active_Poke&#39;] == &#39;Left&#39;
        active_r = self[&#39;Active_Poke&#39;] == &#39;Right&#39;
        correct = ((l * active_l).astype(int) | (r * active_r).astype(int))

        return correct

    def _binary_error_pokes(self):
        l = self._binary_pokes(&#39;left&#39;)
        r = self._binary_pokes(&#39;right&#39;)
        active_l = self[&#39;Active_Poke&#39;] == &#39;Left&#39;
        active_r = self[&#39;Active_Poke&#39;] == &#39;Right&#39;
        error = ((l * active_r).astype(int) | (r * active_l).astype(int))

        return error

    def _binary_pellets(self):
        bp = self[&#39;Pellet_Count&#39;].diff().copy()
        if not bp.empty:
            bp.iloc[0] = int(self.event_type(bp.index[0]) == &#39;Pellet&#39;)

        return bp

    def _binary_poke_for_side(self, side):
        col = {&#39;left&#39;: &#39;Left_Poke_Count&#39;, &#39;right&#39;: &#39;Right_Poke_Count&#39;}[side]
        bp = self[col].diff().copy()
        if not bp.empty:
            bp.iloc[0] = int(self.event_type(bp.index[0]).lower() == side)

        return bp

    def _binary_pokes(self, kind=&#39;any&#39;):
        kind = kind.lower()
        kinds = [&#39;left&#39;, &#39;right&#39;, &#39;any&#39;, &#39;correct&#39;, &#39;error&#39;]
        if kind not in kinds:
            raise ValueError(f&#39;`kind` must be one of  {kinds}, not {kind}&#39;)

        if kind == &#39;any&#39;:
            l = self._binary_poke_for_side(&#39;left&#39;)
            r = self._binary_poke_for_side(&#39;right&#39;)
            bp = ((l == 1) | (r==1)).astype(int)

        elif kind in [&#39;left&#39;, &#39;right&#39;]:
            bp = self._binary_poke_for_side(kind).astype(int)

        elif kind in [&#39;correct&#39;, &#39;error&#39;]:
            bp = self._binary_correct_pokes() if kind == &#39;correct&#39; else self._binary_error_pokes()

        return bp

    def _cumulative_poke_for_side(self, side):
        col = {&#39;left&#39;: &#39;Left_Poke_Count&#39;, &#39;right&#39;: &#39;Right_Poke_Count&#39;}[side]
        cp = self[col]

        return cp

    def _cumulative_pokes(self, kind=&#39;any&#39;):
        kind = kind.lower()
        kinds = [&#39;left&#39;, &#39;right&#39;, &#39;any&#39;, &#39;correct&#39;, &#39;error&#39;]
        if kind not in kinds:
            raise ValueError(f&#39;`kind` must be one of  {kinds}, not {kind}&#39;)

        if kind == &#39;any&#39;:
            l = self._cumulative_poke_for_side(&#39;left&#39;)
            r = self._cumulative_poke_for_side(&#39;right&#39;)
            cp = (l + r).astype(int)

        elif kind in [&#39;left&#39;, &#39;right&#39;]:
            cp = self._cumulative_poke_for_side(kind).astype(int)

        elif kind in [&#39;correct&#39;, &#39;error&#39;]:
            bp = self._binary_correct_pokes() if kind == &#39;correct&#39; else self._binary_error_pokes()
            cp = bp.cumsum()

        return cp

    def _fix_column_names(self):
        &#39;&#39;&#39;
        Checks for and fixes old FED3 issue where column names included a
        trailing/starting space.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        self.foreign_columns = []
        for col in self.columns:
            for fix in FIXED_COLS:
                likeness = SequenceMatcher(a=col, b=fix).ratio()
                if likeness &gt; 0.85:
                    self.rename(columns={col:fix}, inplace=True)
                    break
                self.foreign_columns.append(col)
        self.missing_columns = [col for col in NEEDED_COLS if
                                col not in self.columns]

    def _handle_retrieval_time(self):
        if &#39;Retrieval_Time&#39; not in self.columns:
            return
        self[&#39;Retrieval_Time&#39;] = pd.to_numeric(self[&#39;Retrieval_Time&#39;], errors=&#39;coerce&#39;)


    def _load_init(self, name=None, path=None, deduplicate_index=None):
        &#39;&#39;&#39;
        Initialize FEDFrame attributes and apply some data cleaning.

        This method is marked &#34;private&#34; because it is typically invoked
        automatically when loading data from local files.  The only
        use case is when you have existing pandas data which you want
        to convert into FEDFrame data.  The following demonstrates this
        use case, but note that **it is not recommended**
        (use `fed3.core.load()` instead):

        ```python
        import fed3
        import pandas as pd

        data = pd.read_csv(&#34;/some/file.csv&#34;)
        data = fed3.FEDFrame(data)

        # do the following to get full functionality
        data._load_init()
        ```

        Parameters
        ----------
        name : str, optional
            Name to give the FEDFrame. The default is None.
        path : str, optional
            Set a local data path for the data. The default is None.
        deduplicate_index : str, optional
            When passed, applies a method for handling duplicate timestamps.
            Not passed by default.  See `FEDFrame.deduplicate_index()` for
            allowable methods.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        self.name = name
        self.path = path
        self._fix_column_names()
        self._handle_retrieval_time()
        self._alignment = &#39;datetime&#39;
        self._current_offset = pd.Timedelta(0)
        if deduplicate_index is not None:
            self.deduplicate_index(method=deduplicate_index)
        if self.check_duplicated_index():
            warnings.warn(&#34;Index has duplicate values, which may prevent some &#34;
                          &#34;fed3 operations.  Use the deuplicate_index() method &#34;
                          &#34;to remove duplicate timestamps.&#34;, RuntimeWarning)

    # ---- Public

    def check_duplicated_index(self):
        &#39;&#39;&#39;
        Checks if the data has duplicated timestamps.

        Returns
        -------
        bool
            `True` if duplicates found, else `False`.

        &#39;&#39;&#39;
        return self.index.duplicated().any()

    def deduplicate_index(self, method=&#39;keep_first&#39;, offset=&#39;1S&#39;):
        &#39;&#39;&#39;
        Apply a method to remove duplicate timestamps from the data.

        With FEDFrames, the timestamp column (typically the column
        &#39;MM:DD:YYYY hh:mm:ss&#39;) is used as the row labels (AKA the
        `index` in pandas, [see here](https://pandas.pydata.org/docs/reference/api/pandas.Index.html)).
        Some operations which invole selecting data based on this index
        can fail when there are duplicate entries.

        FED3 data should not generally have duplicated timestamps, however
        they do arise due to two main causes.  One cause is transient
        logging errors, which should be rare (but may be more common with
        earlier FED software).  The other, more common, cause is
        data editing with Microsoft Excel, which has been documented elsewhere
        (see links below).

        Note that this method does not recover any information that is lost;
        it either removes duplicated indices or applies simple rules to alter
        them.  When available, non-duplicated data should be loaded into
        the program.

        fed3 should raise a warning when files with duplicated timestamps
        are loaded. The status of the index can also be checked with
        `check_duplicated_index()`.

        Parameters
        ----------
        method : str, optional
            Method for removing duplicates.  Options are:

            - `&#39;keep_first&#39;`: keep only the first instance of each duplicate
            set (default)
            - `&#39;keep_last&#39;`: keep only the last instance of each duplicate set
            - `&#39;remove&#39;`: delete any rows with duplicate timestamps
            - `&#39;offset&#39;`: add a small time offset to each date - does so
            iteratively until the index is not duplicated.
            - `&#39;interpolate&#39;`: offset duplicates such that they are spaced
            evenly between their value and the next timestamp in the series

            Note that `&#39;interpolate&#39;` and `&#39;offset&#39;` should preserve the
            length of the FEDFrame, while other options can reduce it.

        offset : str, optional
            Pandas time offset string, only used when `method=&#39;offset&#39;`.
            The default is `&#39;1S&#39;`.

        Raises
        ------
        ValueError
            Trying to use `&#39;interpolate&#39;` when the last timestamp is duplicated.

        Returns
        -------
        None.  Data is modified in place.

        &#39;&#39;&#39;

        if method not in [&#39;keep_first&#39;, &#39;keep_last&#39;, &#39;remove&#39;,
                             &#39;offset&#39;, &#39;interpolate&#39;]:
            raise ValueError(f&#39;`method` must be one of {method}, not &#34;{method}&#34;&#39;)

        if method == &#39;keep_first&#39;:
            mask = ~ self.index.duplicated(keep=&#39;first&#39;)
            self.query(&#39;@mask&#39;, inplace=True)
        elif method == &#39;keep_last&#39;:
            mask = ~ self.index.duplicated(keep=&#39;last&#39;)
            self.query(&#39;@mask&#39;, inplace=True)
        elif method == &#39;remove&#39;:
            mask = ~ self.index.duplicated(keep=False)
            self.query(&#39;@mask&#39;, inplace=True)
        elif method == &#39;offset&#39;:
            dt = pd.to_timedelta(offset)
            while self.check_duplicated_index():
                self.index = np.where(self.index.duplicated(),
                                      self.index + dt,
                                      self.index)
        elif method == &#39;interpolate&#39;:
            if self.index.duplicated()[-1]:
                raise ValueError(&#34;Cannot interpolate when the last &#34;
                                 &#34;timestamp is duplicated; try a different &#34;
                                 &#34;deduplication method.&#34;)
            t0 = self.index[0]
            s = pd.Series(self.index)
            s[s.duplicated()] = None
            self.index = t0 + pd.to_timedelta((s - t0).dt.total_seconds().interpolate(), unit=&#39;seconds&#39;)

    def determine_mode(self):
        &#39;&#39;&#39;
        Return the recording mode of the current FED data.  This function tries
        to take this literally from the data headers.  There are likely
        to be problems for custom programs or particular FED software versions.

        Returns
        -------
        mode : str
            String indicating the mode.

        &#39;&#39;&#39;
        mode = &#39;Unknown&#39;
        column = pd.Series(dtype=object)
        for col in [&#39;FR&#39;,&#39;FR_Ratio&#39;,&#39; FR_Ratio&#39;,&#39;Mode&#39;,&#39;Session_Type&#39;]:
            if col in self.columns:
                column = self[col]
        if not column.empty:
            if all(isinstance(i,int) for i in column):
                if len(set(column)) == 1:
                    mode = &#39;FR&#39; + str(column[0])
                else:
                    mode = &#39;PR&#39;
            elif &#39;PR&#39; in column[0]:
                mode = &#39;PR&#39;
            else:
                mode = str(column[0])
        return mode

    def event_type(self, timestamp, poke_side=True):
        &#39;&#39;&#39;
        Return the type of a given timestamp within the data (pellet or poke).

        Parameters
        ----------
        timestamp : str, `pandas.Timestamp`
            timestamp to query.
        poke_side : bool, optional
            When True (default), will try to return `&#39;Left&#39;` or `&#39;Right&#39;`
            when the event is a poke.

        Raises
        ------
        Exception
            Fails when the type can&#39;t automatically be determined.

        Returns
        -------
        str
            Event type for queried timestamp.

        &#39;&#39;&#39;
        if &#39;Event&#39; in self.columns:
            return self.loc[timestamp, &#39;Event&#39;]
        else:
            pellet = self.loc[timestamp, &#39;Pellet_Count&#39;] == 0
            left = self.loc[timestamp, &#39;Left_Poke_Count&#39;] == 0
            right = self.loc[timestamp, &#39;Right_Poke_Count&#39;] == 0
            if sum((pellet, left, right)) == 2:
                if pellet:
                    return &#39;Pellet&#39;
                if left:
                    return &#39;Left&#39; if poke_side else &#39;Poke&#39;
                if right:
                    return &#39;Right&#39; if poke_side else &#39;Poke&#39;
            else:
                raise Exception(&#39;Cannot determine event for timestamp with &#39;
                                &#39;no &#34;Event&#34; column and multiple non-zero &#39;
                                &#39;entries for pellets and pokes.&#39;)

    def interpellet_intervals(self, check_concat=True, condense=False):
        &#39;&#39;&#39;
        Calculate the interpellet intervals for each pellet event.
        This is the time (in minutes) since the last pellet was retrieved.

        Note that there is a shortcut for this method: `ipi`.

        Parameters
        ----------
        check_concat : bool, optional
            Removes IPIs when they are identified as coming directly after
            data concatenation. The default is True.  This will only work
            when data were concatenated with fed3.
        condense : bool, optional
            Return only rows where there are interpellet intervals.
            The default is False.  When False, the returned Series will
            have same length as full FEDFrame.

        Returns
        -------
        interpellet : pandas.Series
            Pandas Series containing the interpellet intervals.

        &#39;&#39;&#39;
        bp = self._binary_pellets()
        bp = bp[bp == 1]
        diff = bp.index.to_series().diff().dt.total_seconds() / 60

        interpellet = pd.Series(np.nan, index = self.index)
        interpellet.loc[diff.index] = diff

        if check_concat and &#39;Concat_#&#39; in self.columns:
            #this can&#39;t do duplicate indexes
            if not any(self.index.duplicated()):
                #thanks to this answer https://stackoverflow.com/a/47115490/13386979
                dropped = interpellet.dropna()
                pos = dropped.index.to_series().groupby(self[&#39;Concat_#&#39;]).first()
                interpellet.loc[pos[1:]] = np.nan

        if condense:
            interpellet = interpellet.loc[bp.index]
            interpellet = _filterout(interpellet, dropna=True)

        return interpellet

    def meals(self, pellet_minimum=1, intermeal_interval=1, condense=False):
        &#39;&#39;&#39;
        Assign a meal number to each pellet retrieval.  Returns a series
        with those assignments.

        Parameters to this function determine what constitutes a meal.
        Assignments are based on interpellet intervals
        (see `FEDFrame.interpellet_intervals()`).

        Parameters
        ----------
        pellet_minimum : int, optional
            Number of pellets required in one meal. The default is 1.  For
            high numbers, some pellets can be unassigned to any meal.
        intermeal_interval : int, optional
            Maximum length of time (in minutes) that can pass between any
            two consecutive pellets assigned to the same meal. The default is 1.
        condense : False, optional
            Return only rows where there are meals (i.e. only pellet index).
            The default is False.  When False, the returned Series will
            have same length as full FEDFrame.

        Returns
        -------
        meals : pandas.Series
            pandas Series with labeled meals

        &#39;&#39;&#39;
        ipi = self.interpellet_intervals(condense=True)
        within_interval = ipi &lt; intermeal_interval
        meals = ((~within_interval).cumsum() + 1)
        above_min = meals.value_counts().sort_index() &gt;= pellet_minimum
        replacements = above_min[above_min].cumsum().reindex(above_min.index)
        meals = meals.map(replacements)
        if not condense:
            meals = meals.reindex(self.index)
        return meals

    def pellets(self, cumulative=True, condense=False):
        &#39;&#39;&#39;
        Provide a series containing pellet retrieval information.

        Parameters
        ----------
        cumulative : bool, optional
            When True (default), the values returned are a cumulative pellet count.
            When False, the values are binary.
        condense : bool, optional
            Return only rows corresponding to pellets.
            The default is False.  When False, the returned Series will
            have same length as full FEDFrame.

        Returns
        -------
        y : pandas Series
            pandas Series containing pellet retrieval counts/indicators.
        &#39;&#39;&#39;
        if cumulative:
            y = self[&#39;Pellet_Count&#39;]
            if condense:
                y = _filterout(y, deduplicate=True, dropzero=True)

        else:
            y = self._binary_pellets()
            if condense:
                y = _filterout(y, dropzero=True)

        return y

    def pokes(self, kind=&#39;any&#39;, cumulative=True, condense=False):
        &#39;&#39;&#39;
        Get an array of poke events.

        Parameters
        ----------
        kind : str, optional
            Key for determining the poke type returned. The default is &#39;any&#39;
            (any poke event).  Other options are &#39;left&#39;, &#39;right&#39;, &#39;correct&#39;,
            and &#39;error&#39;.
        cumulative : bool, optional
            When True (default), the values returned are a cumulative poke count.
            When False, the values are binary.
        condense : bool, optional
            Return only rows corresponding to poke events.
            The default is False.  When False, the returned Series will
            have same length as full FEDFrame.

        Raises
        ------
        ValueError
            Unaccetped key passed to `kind`.

        Returns
        -------
        y : pandas Series
            Pandas Series containing poke counts/indicators.

        &#39;&#39;&#39;

        kind = kind.lower()
        kinds = [&#39;left&#39;, &#39;right&#39;, &#39;any&#39;, &#39;correct&#39;, &#39;error&#39;]
        if kind not in kinds:
            raise ValueError(f&#39;`kind` must be one of  {kinds}, not {kind}&#39;)

        if cumulative:
            y = self._cumulative_pokes(kind)
            if condense:
                y = _filterout(y, deduplicate=True, dropzero=True)

        else:
            y = self._binary_pokes(kind)
            if condense:
                y = _filterout(y, dropzero=True)

        return y

    def reassign_events(self, include_side=True):
        &#39;&#39;&#39;
        Run an intitial assignment or reassignment of the &#34;Event&#34; column.

        Parameters
        ----------
        include_side : bool, optional
            Label poke events with &#34;Left&#34; and &#34;Right&#34; instead of &#34;Poke&#34;.
            The default is True.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        if include_side:
            events = pd.Series(np.nan, index=self.index)
            events.loc[self._binary_pellets().astype(bool)] = &#39;Pellet&#39;
            events.loc[self._binary_pokes(&#39;left&#39;).astype(bool)] = &#39;Left&#39;
            events.loc[self._binary_pokes(&#39;right&#39;).astype(bool)] = &#39;Right&#39;
        else:
            events = np.where(self._binary_pellets(), &#39;Pellet&#39;, &#39;Poke&#39;)
        self[&#39;Event&#39;] = events

    def set_alignment(self, alignment, inplace=True):
        &#39;&#39;&#39;
        Shift the timestamps of a FEDFrame to allow for comparisons with other data
        recorded at different times.

        This is particularly intended for plotting with `fed3.plot`.  By default,
        fed3 will plot fed3 data over the timestamps they were recorded.  For
        temporal plots (with time on the x-axis), this disallows combination
        (e.g. averaging) of data recorded on different dates.  To combine
        these sorts of data, this function will shift the timestamps FEDFrames
        to a common time.

        There are three options for temporal alignment, &#39;datetime&#39;, &#39;time&#39;,
        and &#39;elapsed&#39;.  Note that these are the equivalents of &#39;shared date &amp; time&#39;,
        &#39;shared time&#39;, and &#39;elapsed time&#39; from FED3_Viz.

        - &#39;datetime&#39;: Use the original recorded timestamps for plotting.  This is
        the default behavior for plotting.  This is generally useful when
        all your data were collected at the same time, when you want to show
        exactly when data were recorded, or when working with plots where
        the time of recording does not matter.
        - &#39;time&#39;: Shift the timestamps so that they have the same start date,
        but preserved time of day information.  This is useful for when you
        want to compare or average data recorded on different dates, but want
        to preserve circadian patterns.
        - &#39;elapsed&#39;: Shift the timestamps such that the first recorded timestamp
        is equal to a single, shared date.  This is useful for comparing data
        relative to the initiation of the recording, and you do not need
        to preserve circadian information.

        Note that for &#39;elapsed&#39; and &#39;time&#39; alignment, the common date is set
        by the `ZERO_DATE` variable in this module.

        Parameters
        ----------
        alignment : str, &#39;datetime&#39;, &#39;time&#39;, or &#39;elapsed&#39;
            Option for temporal alignment.  See above for more information.
        inplace : bool, optional
            When True, the current FEDFrame is modified.  Else, a copy is
            returned with the new alignment.

        Raises
        ------
        ValueError
            Option for alignment not recognized.

        Returns
        -------
        newfed : fed3.FEDFrame
            FED3 data with new alignment.

        &#39;&#39;&#39;
        options = [&#39;datetime&#39;, &#39;time&#39;, &#39;elapsed&#39;]

        if alignment not in options:
            raise ValueError(f&#39;`alignment` must be one of {options}, &#39;
                             f&#39;not &#34;{alignment}&#34;&#39;)
        if alignment == &#39;datetime&#39;:
            new_diff = self._current_offset
        elif alignment == &#39;time&#39;:
            new_diff = self.index[0].date() - ZERO_DATE.date()
        elif alignment == &#39;elapsed&#39;:
            new_diff = self.index[0] - ZERO_DATE

        newfed = self if inplace else self.copy()
        newfed.index -= new_diff
        newfed._current_offset -= new_diff
        newfed._alignment = alignment

        return newfed

    # ---- Aliases
    ipi = interpellet_intervals</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pandas.core.frame.DataFrame</li>
<li>pandas.core.generic.NDFrame</li>
<li>pandas.core.base.PandasObject</li>
<li>pandas.core.accessor.DirNamesMixin</li>
<li>pandas.core.indexing.IndexingMixin</li>
<li>pandas.core.arraylike.OpsMixin</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="fed3.core.fedframe.FEDFrame.columns"><code class="name">var <span class="ident">columns</span></code></dt>
<dd>
<div class="desc"><p>The column labels of the DataFrame.</p></div>
</dd>
<dt id="fed3.core.fedframe.FEDFrame.duration"><code class="name">var <span class="ident">duration</span></code></dt>
<dd>
<div class="desc"><p>Time delta of last timestamp and first timestamp.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def duration(self):
    &#34;&#34;&#34;Time delta of last timestamp and first timestamp.&#34;&#34;&#34;
    return self.end_time-self.start_time</code></pre>
</details>
</dd>
<dt id="fed3.core.fedframe.FEDFrame.end_time"><code class="name">var <span class="ident">end_time</span></code></dt>
<dd>
<div class="desc"><p>Last timestamp in file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def end_time(self):
    &#34;&#34;&#34;Last timestamp in file.&#34;&#34;&#34;
    return pd.Timestamp(self.index.values[-1])</code></pre>
</details>
</dd>
<dt id="fed3.core.fedframe.FEDFrame.events"><code class="name">var <span class="ident">events</span></code></dt>
<dd>
<div class="desc"><p>Number of logged events (i.e. rows).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def events(self):
    &#39;&#39;&#39;Number of logged events (i.e. rows).&#39;&#39;&#39;
    return len(self.data)</code></pre>
</details>
</dd>
<dt id="fed3.core.fedframe.FEDFrame.fedmode"><code class="name">var <span class="ident">fedmode</span></code></dt>
<dd>
<div class="desc"><p>FED3 operating mode for this data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fedmode(self):
    &#39;&#39;&#39;FED3 operating mode for this data.&#39;&#39;&#39;
    return self.determine_mode()</code></pre>
</details>
</dd>
<dt id="fed3.core.fedframe.FEDFrame.index"><code class="name">var <span class="ident">index</span></code></dt>
<dd>
<div class="desc"><p>The index (row labels) of the DataFrame.</p></div>
</dd>
<dt id="fed3.core.fedframe.FEDFrame.start_time"><code class="name">var <span class="ident">start_time</span></code></dt>
<dd>
<div class="desc"><p>First timestamp in file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def start_time(self):
    &#39;&#39;&#39;First timestamp in file.&#39;&#39;&#39;
    return pd.Timestamp(self.index.values[0])</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fed3.core.fedframe.FEDFrame._load_init"><code class="name flex">
<span>def <span class="ident">_load_init</span></span>(<span>self, name=None, path=None, deduplicate_index=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize FEDFrame attributes and apply some data cleaning.</p>
<p>This method is marked "private" because it is typically invoked
automatically when loading data from local files.
The only
use case is when you have existing pandas data which you want
to convert into FEDFrame data.
The following demonstrates this
use case, but note that <strong>it is not recommended</strong>
(use <code><a title="fed3.core.load" href="index.html#fed3.core.load">load()</a></code> instead):</p>
<pre><code class="language-python">import fed3
import pandas as pd

data = pd.read_csv(&quot;/some/file.csv&quot;)
data = fed3.FEDFrame(data)

# do the following to get full functionality
data._load_init()
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name to give the FEDFrame. The default is None.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Set a local data path for the data. The default is None.</dd>
<dt><strong><code>deduplicate_index</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>When passed, applies a method for handling duplicate timestamps.
Not passed by default.
See <code><a title="fed3.core.fedframe.FEDFrame.deduplicate_index" href="#fed3.core.fedframe.FEDFrame.deduplicate_index">FEDFrame.deduplicate_index()</a></code> for
allowable methods.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _load_init(self, name=None, path=None, deduplicate_index=None):
    &#39;&#39;&#39;
    Initialize FEDFrame attributes and apply some data cleaning.

    This method is marked &#34;private&#34; because it is typically invoked
    automatically when loading data from local files.  The only
    use case is when you have existing pandas data which you want
    to convert into FEDFrame data.  The following demonstrates this
    use case, but note that **it is not recommended**
    (use `fed3.core.load()` instead):

    ```python
    import fed3
    import pandas as pd

    data = pd.read_csv(&#34;/some/file.csv&#34;)
    data = fed3.FEDFrame(data)

    # do the following to get full functionality
    data._load_init()
    ```

    Parameters
    ----------
    name : str, optional
        Name to give the FEDFrame. The default is None.
    path : str, optional
        Set a local data path for the data. The default is None.
    deduplicate_index : str, optional
        When passed, applies a method for handling duplicate timestamps.
        Not passed by default.  See `FEDFrame.deduplicate_index()` for
        allowable methods.

    Returns
    -------
    None.

    &#39;&#39;&#39;
    self.name = name
    self.path = path
    self._fix_column_names()
    self._handle_retrieval_time()
    self._alignment = &#39;datetime&#39;
    self._current_offset = pd.Timedelta(0)
    if deduplicate_index is not None:
        self.deduplicate_index(method=deduplicate_index)
    if self.check_duplicated_index():
        warnings.warn(&#34;Index has duplicate values, which may prevent some &#34;
                      &#34;fed3 operations.  Use the deuplicate_index() method &#34;
                      &#34;to remove duplicate timestamps.&#34;, RuntimeWarning)</code></pre>
</details>
</dd>
<dt id="fed3.core.fedframe.FEDFrame.check_duplicated_index"><code class="name flex">
<span>def <span class="ident">check_duplicated_index</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the data has duplicated timestamps.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd><code>True</code> if duplicates found, else <code>False</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_duplicated_index(self):
    &#39;&#39;&#39;
    Checks if the data has duplicated timestamps.

    Returns
    -------
    bool
        `True` if duplicates found, else `False`.

    &#39;&#39;&#39;
    return self.index.duplicated().any()</code></pre>
</details>
</dd>
<dt id="fed3.core.fedframe.FEDFrame.deduplicate_index"><code class="name flex">
<span>def <span class="ident">deduplicate_index</span></span>(<span>self, method='keep_first', offset='1S')</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a method to remove duplicate timestamps from the data.</p>
<p>With FEDFrames, the timestamp column (typically the column
'MM:DD:YYYY hh:mm:ss') is used as the row labels (AKA the
<code>index</code> in pandas, <a href="https://pandas.pydata.org/docs/reference/api/pandas.Index.html">see here</a>).
Some operations which invole selecting data based on this index
can fail when there are duplicate entries.</p>
<p>FED3 data should not generally have duplicated timestamps, however
they do arise due to two main causes.
One cause is transient
logging errors, which should be rare (but may be more common with
earlier FED software).
The other, more common, cause is
data editing with Microsoft Excel, which has been documented elsewhere
(see links below).</p>
<p>Note that this method does not recover any information that is lost;
it either removes duplicated indices or applies simple rules to alter
them.
When available, non-duplicated data should be loaded into
the program.</p>
<p>fed3 should raise a warning when files with duplicated timestamps
are loaded. The status of the index can also be checked with
<code>check_duplicated_index()</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>
<p>Method for removing duplicates.
Options are:</p>
<ul>
<li><code>'keep_first'</code>: keep only the first instance of each duplicate
set (default)</li>
<li><code>'keep_last'</code>: keep only the last instance of each duplicate set</li>
<li><code>'remove'</code>: delete any rows with duplicate timestamps</li>
<li><code>'offset'</code>: add a small time offset to each date - does so
iteratively until the index is not duplicated.</li>
<li><code>'interpolate'</code>: offset duplicates such that they are spaced
evenly between their value and the next timestamp in the series</li>
</ul>
<p>Note that <code>'interpolate'</code> and <code>'offset'</code> should preserve the
length of the FEDFrame, while other options can reduce it.</p>
</dd>
<dt><strong><code>offset</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Pandas time offset string, only used when <code>method='offset'</code>.
The default is <code>'1S'</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Trying to use <code>'interpolate'</code> when the last timestamp is duplicated.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.
Data is modified in place.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deduplicate_index(self, method=&#39;keep_first&#39;, offset=&#39;1S&#39;):
    &#39;&#39;&#39;
    Apply a method to remove duplicate timestamps from the data.

    With FEDFrames, the timestamp column (typically the column
    &#39;MM:DD:YYYY hh:mm:ss&#39;) is used as the row labels (AKA the
    `index` in pandas, [see here](https://pandas.pydata.org/docs/reference/api/pandas.Index.html)).
    Some operations which invole selecting data based on this index
    can fail when there are duplicate entries.

    FED3 data should not generally have duplicated timestamps, however
    they do arise due to two main causes.  One cause is transient
    logging errors, which should be rare (but may be more common with
    earlier FED software).  The other, more common, cause is
    data editing with Microsoft Excel, which has been documented elsewhere
    (see links below).

    Note that this method does not recover any information that is lost;
    it either removes duplicated indices or applies simple rules to alter
    them.  When available, non-duplicated data should be loaded into
    the program.

    fed3 should raise a warning when files with duplicated timestamps
    are loaded. The status of the index can also be checked with
    `check_duplicated_index()`.

    Parameters
    ----------
    method : str, optional
        Method for removing duplicates.  Options are:

        - `&#39;keep_first&#39;`: keep only the first instance of each duplicate
        set (default)
        - `&#39;keep_last&#39;`: keep only the last instance of each duplicate set
        - `&#39;remove&#39;`: delete any rows with duplicate timestamps
        - `&#39;offset&#39;`: add a small time offset to each date - does so
        iteratively until the index is not duplicated.
        - `&#39;interpolate&#39;`: offset duplicates such that they are spaced
        evenly between their value and the next timestamp in the series

        Note that `&#39;interpolate&#39;` and `&#39;offset&#39;` should preserve the
        length of the FEDFrame, while other options can reduce it.

    offset : str, optional
        Pandas time offset string, only used when `method=&#39;offset&#39;`.
        The default is `&#39;1S&#39;`.

    Raises
    ------
    ValueError
        Trying to use `&#39;interpolate&#39;` when the last timestamp is duplicated.

    Returns
    -------
    None.  Data is modified in place.

    &#39;&#39;&#39;

    if method not in [&#39;keep_first&#39;, &#39;keep_last&#39;, &#39;remove&#39;,
                         &#39;offset&#39;, &#39;interpolate&#39;]:
        raise ValueError(f&#39;`method` must be one of {method}, not &#34;{method}&#34;&#39;)

    if method == &#39;keep_first&#39;:
        mask = ~ self.index.duplicated(keep=&#39;first&#39;)
        self.query(&#39;@mask&#39;, inplace=True)
    elif method == &#39;keep_last&#39;:
        mask = ~ self.index.duplicated(keep=&#39;last&#39;)
        self.query(&#39;@mask&#39;, inplace=True)
    elif method == &#39;remove&#39;:
        mask = ~ self.index.duplicated(keep=False)
        self.query(&#39;@mask&#39;, inplace=True)
    elif method == &#39;offset&#39;:
        dt = pd.to_timedelta(offset)
        while self.check_duplicated_index():
            self.index = np.where(self.index.duplicated(),
                                  self.index + dt,
                                  self.index)
    elif method == &#39;interpolate&#39;:
        if self.index.duplicated()[-1]:
            raise ValueError(&#34;Cannot interpolate when the last &#34;
                             &#34;timestamp is duplicated; try a different &#34;
                             &#34;deduplication method.&#34;)
        t0 = self.index[0]
        s = pd.Series(self.index)
        s[s.duplicated()] = None
        self.index = t0 + pd.to_timedelta((s - t0).dt.total_seconds().interpolate(), unit=&#39;seconds&#39;)</code></pre>
</details>
</dd>
<dt id="fed3.core.fedframe.FEDFrame.determine_mode"><code class="name flex">
<span>def <span class="ident">determine_mode</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the recording mode of the current FED data.
This function tries
to take this literally from the data headers.
There are likely
to be problems for custom programs or particular FED software versions.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>String indicating the mode.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def determine_mode(self):
    &#39;&#39;&#39;
    Return the recording mode of the current FED data.  This function tries
    to take this literally from the data headers.  There are likely
    to be problems for custom programs or particular FED software versions.

    Returns
    -------
    mode : str
        String indicating the mode.

    &#39;&#39;&#39;
    mode = &#39;Unknown&#39;
    column = pd.Series(dtype=object)
    for col in [&#39;FR&#39;,&#39;FR_Ratio&#39;,&#39; FR_Ratio&#39;,&#39;Mode&#39;,&#39;Session_Type&#39;]:
        if col in self.columns:
            column = self[col]
    if not column.empty:
        if all(isinstance(i,int) for i in column):
            if len(set(column)) == 1:
                mode = &#39;FR&#39; + str(column[0])
            else:
                mode = &#39;PR&#39;
        elif &#39;PR&#39; in column[0]:
            mode = &#39;PR&#39;
        else:
            mode = str(column[0])
    return mode</code></pre>
</details>
</dd>
<dt id="fed3.core.fedframe.FEDFrame.event_type"><code class="name flex">
<span>def <span class="ident">event_type</span></span>(<span>self, timestamp, poke_side=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the type of a given timestamp within the data (pellet or poke).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>timestamp</code></strong> :&ensp;<code>str, </code>pandas.Timestamp``</dt>
<dd>timestamp to query.</dd>
<dt><strong><code>poke_side</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>When True (default), will try to return <code>'Left'</code> or <code>'Right'</code>
when the event is a poke.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Exception</code></dt>
<dd>Fails when the type can't automatically be determined.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Event type for queried timestamp.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def event_type(self, timestamp, poke_side=True):
    &#39;&#39;&#39;
    Return the type of a given timestamp within the data (pellet or poke).

    Parameters
    ----------
    timestamp : str, `pandas.Timestamp`
        timestamp to query.
    poke_side : bool, optional
        When True (default), will try to return `&#39;Left&#39;` or `&#39;Right&#39;`
        when the event is a poke.

    Raises
    ------
    Exception
        Fails when the type can&#39;t automatically be determined.

    Returns
    -------
    str
        Event type for queried timestamp.

    &#39;&#39;&#39;
    if &#39;Event&#39; in self.columns:
        return self.loc[timestamp, &#39;Event&#39;]
    else:
        pellet = self.loc[timestamp, &#39;Pellet_Count&#39;] == 0
        left = self.loc[timestamp, &#39;Left_Poke_Count&#39;] == 0
        right = self.loc[timestamp, &#39;Right_Poke_Count&#39;] == 0
        if sum((pellet, left, right)) == 2:
            if pellet:
                return &#39;Pellet&#39;
            if left:
                return &#39;Left&#39; if poke_side else &#39;Poke&#39;
            if right:
                return &#39;Right&#39; if poke_side else &#39;Poke&#39;
        else:
            raise Exception(&#39;Cannot determine event for timestamp with &#39;
                            &#39;no &#34;Event&#34; column and multiple non-zero &#39;
                            &#39;entries for pellets and pokes.&#39;)</code></pre>
</details>
</dd>
<dt id="fed3.core.fedframe.FEDFrame.interpellet_intervals"><code class="name flex">
<span>def <span class="ident">interpellet_intervals</span></span>(<span>self, check_concat=True, condense=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the interpellet intervals for each pellet event.
This is the time (in minutes) since the last pellet was retrieved.</p>
<p>Note that there is a shortcut for this method: <code>ipi</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>check_concat</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Removes IPIs when they are identified as coming directly after
data concatenation. The default is True.
This will only work
when data were concatenated with fed3.</dd>
<dt><strong><code>condense</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Return only rows where there are interpellet intervals.
The default is False.
When False, the returned Series will
have same length as full FEDFrame.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>interpellet</code></strong> :&ensp;<code>pandas.Series</code></dt>
<dd>Pandas Series containing the interpellet intervals.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpellet_intervals(self, check_concat=True, condense=False):
    &#39;&#39;&#39;
    Calculate the interpellet intervals for each pellet event.
    This is the time (in minutes) since the last pellet was retrieved.

    Note that there is a shortcut for this method: `ipi`.

    Parameters
    ----------
    check_concat : bool, optional
        Removes IPIs when they are identified as coming directly after
        data concatenation. The default is True.  This will only work
        when data were concatenated with fed3.
    condense : bool, optional
        Return only rows where there are interpellet intervals.
        The default is False.  When False, the returned Series will
        have same length as full FEDFrame.

    Returns
    -------
    interpellet : pandas.Series
        Pandas Series containing the interpellet intervals.

    &#39;&#39;&#39;
    bp = self._binary_pellets()
    bp = bp[bp == 1]
    diff = bp.index.to_series().diff().dt.total_seconds() / 60

    interpellet = pd.Series(np.nan, index = self.index)
    interpellet.loc[diff.index] = diff

    if check_concat and &#39;Concat_#&#39; in self.columns:
        #this can&#39;t do duplicate indexes
        if not any(self.index.duplicated()):
            #thanks to this answer https://stackoverflow.com/a/47115490/13386979
            dropped = interpellet.dropna()
            pos = dropped.index.to_series().groupby(self[&#39;Concat_#&#39;]).first()
            interpellet.loc[pos[1:]] = np.nan

    if condense:
        interpellet = interpellet.loc[bp.index]
        interpellet = _filterout(interpellet, dropna=True)

    return interpellet</code></pre>
</details>
</dd>
<dt id="fed3.core.fedframe.FEDFrame.meals"><code class="name flex">
<span>def <span class="ident">meals</span></span>(<span>self, pellet_minimum=1, intermeal_interval=1, condense=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Assign a meal number to each pellet retrieval.
Returns a series
with those assignments.</p>
<p>Parameters to this function determine what constitutes a meal.
Assignments are based on interpellet intervals
(see <code><a title="fed3.core.fedframe.FEDFrame.interpellet_intervals" href="#fed3.core.fedframe.FEDFrame.interpellet_intervals">FEDFrame.interpellet_intervals()</a></code>).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pellet_minimum</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of pellets required in one meal. The default is 1.
For
high numbers, some pellets can be unassigned to any meal.</dd>
<dt><strong><code>intermeal_interval</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Maximum length of time (in minutes) that can pass between any
two consecutive pellets assigned to the same meal. The default is 1.</dd>
<dt><strong><code>condense</code></strong> :&ensp;<code>False</code>, optional</dt>
<dd>Return only rows where there are meals (i.e. only pellet index).
The default is False.
When False, the returned Series will
have same length as full FEDFrame.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>meals</code></strong> :&ensp;<code>pandas.Series</code></dt>
<dd>pandas Series with labeled meals</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def meals(self, pellet_minimum=1, intermeal_interval=1, condense=False):
    &#39;&#39;&#39;
    Assign a meal number to each pellet retrieval.  Returns a series
    with those assignments.

    Parameters to this function determine what constitutes a meal.
    Assignments are based on interpellet intervals
    (see `FEDFrame.interpellet_intervals()`).

    Parameters
    ----------
    pellet_minimum : int, optional
        Number of pellets required in one meal. The default is 1.  For
        high numbers, some pellets can be unassigned to any meal.
    intermeal_interval : int, optional
        Maximum length of time (in minutes) that can pass between any
        two consecutive pellets assigned to the same meal. The default is 1.
    condense : False, optional
        Return only rows where there are meals (i.e. only pellet index).
        The default is False.  When False, the returned Series will
        have same length as full FEDFrame.

    Returns
    -------
    meals : pandas.Series
        pandas Series with labeled meals

    &#39;&#39;&#39;
    ipi = self.interpellet_intervals(condense=True)
    within_interval = ipi &lt; intermeal_interval
    meals = ((~within_interval).cumsum() + 1)
    above_min = meals.value_counts().sort_index() &gt;= pellet_minimum
    replacements = above_min[above_min].cumsum().reindex(above_min.index)
    meals = meals.map(replacements)
    if not condense:
        meals = meals.reindex(self.index)
    return meals</code></pre>
</details>
</dd>
<dt id="fed3.core.fedframe.FEDFrame.pellets"><code class="name flex">
<span>def <span class="ident">pellets</span></span>(<span>self, cumulative=True, condense=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Provide a series containing pellet retrieval information.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cumulative</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>When True (default), the values returned are a cumulative pellet count.
When False, the values are binary.</dd>
<dt><strong><code>condense</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Return only rows corresponding to pellets.
The default is False.
When False, the returned Series will
have same length as full FEDFrame.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>pandas Series</code></dt>
<dd>pandas Series containing pellet retrieval counts/indicators.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pellets(self, cumulative=True, condense=False):
    &#39;&#39;&#39;
    Provide a series containing pellet retrieval information.

    Parameters
    ----------
    cumulative : bool, optional
        When True (default), the values returned are a cumulative pellet count.
        When False, the values are binary.
    condense : bool, optional
        Return only rows corresponding to pellets.
        The default is False.  When False, the returned Series will
        have same length as full FEDFrame.

    Returns
    -------
    y : pandas Series
        pandas Series containing pellet retrieval counts/indicators.
    &#39;&#39;&#39;
    if cumulative:
        y = self[&#39;Pellet_Count&#39;]
        if condense:
            y = _filterout(y, deduplicate=True, dropzero=True)

    else:
        y = self._binary_pellets()
        if condense:
            y = _filterout(y, dropzero=True)

    return y</code></pre>
</details>
</dd>
<dt id="fed3.core.fedframe.FEDFrame.pokes"><code class="name flex">
<span>def <span class="ident">pokes</span></span>(<span>self, kind='any', cumulative=True, condense=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Get an array of poke events.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>kind</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Key for determining the poke type returned. The default is 'any'
(any poke event).
Other options are 'left', 'right', 'correct',
and 'error'.</dd>
<dt><strong><code>cumulative</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>When True (default), the values returned are a cumulative poke count.
When False, the values are binary.</dd>
<dt><strong><code>condense</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Return only rows corresponding to poke events.
The default is False.
When False, the returned Series will
have same length as full FEDFrame.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Unaccetped key passed to <code>kind</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>pandas Series</code></dt>
<dd>Pandas Series containing poke counts/indicators.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pokes(self, kind=&#39;any&#39;, cumulative=True, condense=False):
    &#39;&#39;&#39;
    Get an array of poke events.

    Parameters
    ----------
    kind : str, optional
        Key for determining the poke type returned. The default is &#39;any&#39;
        (any poke event).  Other options are &#39;left&#39;, &#39;right&#39;, &#39;correct&#39;,
        and &#39;error&#39;.
    cumulative : bool, optional
        When True (default), the values returned are a cumulative poke count.
        When False, the values are binary.
    condense : bool, optional
        Return only rows corresponding to poke events.
        The default is False.  When False, the returned Series will
        have same length as full FEDFrame.

    Raises
    ------
    ValueError
        Unaccetped key passed to `kind`.

    Returns
    -------
    y : pandas Series
        Pandas Series containing poke counts/indicators.

    &#39;&#39;&#39;

    kind = kind.lower()
    kinds = [&#39;left&#39;, &#39;right&#39;, &#39;any&#39;, &#39;correct&#39;, &#39;error&#39;]
    if kind not in kinds:
        raise ValueError(f&#39;`kind` must be one of  {kinds}, not {kind}&#39;)

    if cumulative:
        y = self._cumulative_pokes(kind)
        if condense:
            y = _filterout(y, deduplicate=True, dropzero=True)

    else:
        y = self._binary_pokes(kind)
        if condense:
            y = _filterout(y, dropzero=True)

    return y</code></pre>
</details>
</dd>
<dt id="fed3.core.fedframe.FEDFrame.reassign_events"><code class="name flex">
<span>def <span class="ident">reassign_events</span></span>(<span>self, include_side=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Run an intitial assignment or reassignment of the "Event" column.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>include_side</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Label poke events with "Left" and "Right" instead of "Poke".
The default is True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reassign_events(self, include_side=True):
    &#39;&#39;&#39;
    Run an intitial assignment or reassignment of the &#34;Event&#34; column.

    Parameters
    ----------
    include_side : bool, optional
        Label poke events with &#34;Left&#34; and &#34;Right&#34; instead of &#34;Poke&#34;.
        The default is True.

    Returns
    -------
    None.

    &#39;&#39;&#39;
    if include_side:
        events = pd.Series(np.nan, index=self.index)
        events.loc[self._binary_pellets().astype(bool)] = &#39;Pellet&#39;
        events.loc[self._binary_pokes(&#39;left&#39;).astype(bool)] = &#39;Left&#39;
        events.loc[self._binary_pokes(&#39;right&#39;).astype(bool)] = &#39;Right&#39;
    else:
        events = np.where(self._binary_pellets(), &#39;Pellet&#39;, &#39;Poke&#39;)
    self[&#39;Event&#39;] = events</code></pre>
</details>
</dd>
<dt id="fed3.core.fedframe.FEDFrame.set_alignment"><code class="name flex">
<span>def <span class="ident">set_alignment</span></span>(<span>self, alignment, inplace=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Shift the timestamps of a FEDFrame to allow for comparisons with other data
recorded at different times.</p>
<p>This is particularly intended for plotting with <code><a title="fed3.plot" href="../plot/index.html">fed3.plot</a></code>.
By default,
fed3 will plot fed3 data over the timestamps they were recorded.
For
temporal plots (with time on the x-axis), this disallows combination
(e.g. averaging) of data recorded on different dates.
To combine
these sorts of data, this function will shift the timestamps FEDFrames
to a common time.</p>
<p>There are three options for temporal alignment, 'datetime', 'time',
and 'elapsed'.
Note that these are the equivalents of 'shared date &amp; time',
'shared time', and 'elapsed time' from FED3_Viz.</p>
<ul>
<li>'datetime': Use the original recorded timestamps for plotting.
This is
the default behavior for plotting.
This is generally useful when
all your data were collected at the same time, when you want to show
exactly when data were recorded, or when working with plots where
the time of recording does not matter.</li>
<li>'time': Shift the timestamps so that they have the same start date,
but preserved time of day information.
This is useful for when you
want to compare or average data recorded on different dates, but want
to preserve circadian patterns.</li>
<li>'elapsed': Shift the timestamps such that the first recorded timestamp
is equal to a single, shared date.
This is useful for comparing data
relative to the initiation of the recording, and you do not need
to preserve circadian information.</li>
</ul>
<p>Note that for 'elapsed' and 'time' alignment, the common date is set
by the <code>ZERO_DATE</code> variable in this module.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>alignment</code></strong> :&ensp;<code>str, 'datetime', 'time',</code> or <code>'elapsed'</code></dt>
<dd>Option for temporal alignment.
See above for more information.</dd>
<dt><strong><code>inplace</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>When True, the current FEDFrame is modified.
Else, a copy is
returned with the new alignment.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Option for alignment not recognized.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>newfed</code></strong> :&ensp;<code><a title="fed3.FEDFrame" href="../index.html#fed3.FEDFrame">FEDFrame</a></code></dt>
<dd>FED3 data with new alignment.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_alignment(self, alignment, inplace=True):
    &#39;&#39;&#39;
    Shift the timestamps of a FEDFrame to allow for comparisons with other data
    recorded at different times.

    This is particularly intended for plotting with `fed3.plot`.  By default,
    fed3 will plot fed3 data over the timestamps they were recorded.  For
    temporal plots (with time on the x-axis), this disallows combination
    (e.g. averaging) of data recorded on different dates.  To combine
    these sorts of data, this function will shift the timestamps FEDFrames
    to a common time.

    There are three options for temporal alignment, &#39;datetime&#39;, &#39;time&#39;,
    and &#39;elapsed&#39;.  Note that these are the equivalents of &#39;shared date &amp; time&#39;,
    &#39;shared time&#39;, and &#39;elapsed time&#39; from FED3_Viz.

    - &#39;datetime&#39;: Use the original recorded timestamps for plotting.  This is
    the default behavior for plotting.  This is generally useful when
    all your data were collected at the same time, when you want to show
    exactly when data were recorded, or when working with plots where
    the time of recording does not matter.
    - &#39;time&#39;: Shift the timestamps so that they have the same start date,
    but preserved time of day information.  This is useful for when you
    want to compare or average data recorded on different dates, but want
    to preserve circadian patterns.
    - &#39;elapsed&#39;: Shift the timestamps such that the first recorded timestamp
    is equal to a single, shared date.  This is useful for comparing data
    relative to the initiation of the recording, and you do not need
    to preserve circadian information.

    Note that for &#39;elapsed&#39; and &#39;time&#39; alignment, the common date is set
    by the `ZERO_DATE` variable in this module.

    Parameters
    ----------
    alignment : str, &#39;datetime&#39;, &#39;time&#39;, or &#39;elapsed&#39;
        Option for temporal alignment.  See above for more information.
    inplace : bool, optional
        When True, the current FEDFrame is modified.  Else, a copy is
        returned with the new alignment.

    Raises
    ------
    ValueError
        Option for alignment not recognized.

    Returns
    -------
    newfed : fed3.FEDFrame
        FED3 data with new alignment.

    &#39;&#39;&#39;
    options = [&#39;datetime&#39;, &#39;time&#39;, &#39;elapsed&#39;]

    if alignment not in options:
        raise ValueError(f&#39;`alignment` must be one of {options}, &#39;
                         f&#39;not &#34;{alignment}&#34;&#39;)
    if alignment == &#39;datetime&#39;:
        new_diff = self._current_offset
    elif alignment == &#39;time&#39;:
        new_diff = self.index[0].date() - ZERO_DATE.date()
    elif alignment == &#39;elapsed&#39;:
        new_diff = self.index[0] - ZERO_DATE

    newfed = self if inplace else self.copy()
    newfed.index -= new_diff
    newfed._current_offset -= new_diff
    newfed._alignment = alignment

    return newfed</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fed3.core" href="index.html">fed3.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fed3.core.fedframe.FEDFrame" href="#fed3.core.fedframe.FEDFrame">FEDFrame</a></code></h4>
<ul class="">
<li><code><a title="fed3.core.fedframe.FEDFrame._load_init" href="#fed3.core.fedframe.FEDFrame._load_init">_load_init</a></code></li>
<li><code><a title="fed3.core.fedframe.FEDFrame.check_duplicated_index" href="#fed3.core.fedframe.FEDFrame.check_duplicated_index">check_duplicated_index</a></code></li>
<li><code><a title="fed3.core.fedframe.FEDFrame.columns" href="#fed3.core.fedframe.FEDFrame.columns">columns</a></code></li>
<li><code><a title="fed3.core.fedframe.FEDFrame.deduplicate_index" href="#fed3.core.fedframe.FEDFrame.deduplicate_index">deduplicate_index</a></code></li>
<li><code><a title="fed3.core.fedframe.FEDFrame.determine_mode" href="#fed3.core.fedframe.FEDFrame.determine_mode">determine_mode</a></code></li>
<li><code><a title="fed3.core.fedframe.FEDFrame.duration" href="#fed3.core.fedframe.FEDFrame.duration">duration</a></code></li>
<li><code><a title="fed3.core.fedframe.FEDFrame.end_time" href="#fed3.core.fedframe.FEDFrame.end_time">end_time</a></code></li>
<li><code><a title="fed3.core.fedframe.FEDFrame.event_type" href="#fed3.core.fedframe.FEDFrame.event_type">event_type</a></code></li>
<li><code><a title="fed3.core.fedframe.FEDFrame.events" href="#fed3.core.fedframe.FEDFrame.events">events</a></code></li>
<li><code><a title="fed3.core.fedframe.FEDFrame.fedmode" href="#fed3.core.fedframe.FEDFrame.fedmode">fedmode</a></code></li>
<li><code><a title="fed3.core.fedframe.FEDFrame.index" href="#fed3.core.fedframe.FEDFrame.index">index</a></code></li>
<li><code><a title="fed3.core.fedframe.FEDFrame.interpellet_intervals" href="#fed3.core.fedframe.FEDFrame.interpellet_intervals">interpellet_intervals</a></code></li>
<li><code><a title="fed3.core.fedframe.FEDFrame.meals" href="#fed3.core.fedframe.FEDFrame.meals">meals</a></code></li>
<li><code><a title="fed3.core.fedframe.FEDFrame.pellets" href="#fed3.core.fedframe.FEDFrame.pellets">pellets</a></code></li>
<li><code><a title="fed3.core.fedframe.FEDFrame.pokes" href="#fed3.core.fedframe.FEDFrame.pokes">pokes</a></code></li>
<li><code><a title="fed3.core.fedframe.FEDFrame.reassign_events" href="#fed3.core.fedframe.FEDFrame.reassign_events">reassign_events</a></code></li>
<li><code><a title="fed3.core.fedframe.FEDFrame.set_alignment" href="#fed3.core.fedframe.FEDFrame.set_alignment">set_alignment</a></code></li>
<li><code><a title="fed3.core.fedframe.FEDFrame.start_time" href="#fed3.core.fedframe.FEDFrame.start_time">start_time</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>